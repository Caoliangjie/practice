# Practice
不同路径
## 问题分析：
#### 
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
问总共有多少条不同的路径？
## 说明：
 m 和 n 的值均不超过 100。
## 编程实现：
```C++
class Solution {
public:
    int uniquePaths(int m, int n) {
        if (m == 0 || n == 0) {
            return 0;
        }
       int s[100][100]={};
        for (int i = 0; i < m; i++)
            s[i][0] = 1;
        for (int i = 0; i < n; i++)
            s[0][i] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                s[i][j] = s[i-1][j] + s[i][j-1];
            }
        }
        return s[m-1][n-1];
    }
};
```
## 总结体会：
我们这里使用一个二维数组s记忆到达每一点可行的走法总数。首先将左边界点和上边界点初始化为1，因为机器人起始点与（0，0），左边界点和上边界点的走法只有1种。接下来的每一点（x,y），可以由（x-1，y）向右走或是（x,y-1）向下走来到达，因此在（x,y）这一点可到达的方法一共有s[x-1][y]+s[x][y-1]种。这样到达终点的方法就是s最后一个点的数据。